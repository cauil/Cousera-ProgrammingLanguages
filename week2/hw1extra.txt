Here are some extra programming problems that can be done using the material in this module. Many are similar in difficulty and content to the homework, but they are not the homework, so you are free to discuss solutions, etc. on the discussion forum. Thanks to Charilaos Skiadas for contributing these.

Write a function ğšŠğš•ğšğšğš›ğš—ğšŠğšğš : ğš’ğš—ğš ğš•ğš’ğšœğš -> ğš’ğš—ğš that takes a list of numbers and adds them with alternating sign. For example ğšŠğš•ğšğšğš›ğš—ğšŠğšğš [ğŸ·,ğŸ¸,ğŸ¹,ğŸº] = ğŸ· - ğŸ¸ + ğŸ¹ - ğŸº = -ğŸ¸.
Write a function ğš–ğš’ğš—_ğš–ğšŠğš¡ : ğš’ğš—ğš ğš•ğš’ğšœğš -> ğš’ğš—ğš * ğš’ğš—ğš that takes a non-empty list of numbers, and returns a pair (ğš–ğš’ğš—, ğš–ğšŠğš¡) of the minimum and maximum of the numbers in the list.
Write a function ğšŒğšğš–ğšœğšğš– : ğš’ğš—ğš ğš•ğš’ğšœğš -> ğš’ğš—ğš ğš•ğš’ğšœğš that takes a list of numbers and returns a list of the partial sums of those numbers. For example ğšŒğšğš–ğšœğšğš– [ğŸ·,ğŸº,ğŸ¸ğŸ¶] = [ğŸ·,ğŸ»,ğŸ¸ğŸ»].
Write a function ğšğš›ğšğšğšğš’ğš—ğš : ğšœğšğš›ğš’ğš—ğš ğš˜ğš™ğšğš’ğš˜ğš— -> ğšœğšğš›ğš’ğš—ğš that given a string option ğš‚ğ™¾ğ™¼ğ™´ name returns the string "ğ™·ğšğš•ğš•ğš˜ ğšğš‘ğšğš›ğš, ...!" where the dots would be replaced by name. Note that the name is given as an option, so if it is ğ™½ğ™¾ğ™½ğ™´ then replace the dots with "ğš¢ğš˜ğš".
Write a function ğš›ğšğš™ğšğšŠğš : ğš’ğš—ğš ğš•ğš’ğšœğš * ğš’ğš—ğš ğš•ğš’ğšœğš -> ğš’ğš—ğš ğš•ğš’ğšœğš that given a list of integers and another list of nonnegative integers, repeats the integers in the first list according to the numbers indicated by the second list. For example: ğš›ğšğš™ğšğšŠğš ([ğŸ·,ğŸ¸,ğŸ¹], [ğŸº,ğŸ¶,ğŸ¹]) = [ğŸ·,ğŸ·,ğŸ·,ğŸ·,ğŸ¹,ğŸ¹,ğŸ¹].
Write a function ğšŠğšğšğ™¾ğš™ğš : ğš’ğš—ğš ğš˜ğš™ğšğš’ğš˜ğš— * ğš’ğš—ğš ğš˜ğš™ğšğš’ğš˜ğš— -> ğš’ğš—ğš ğš˜ğš™ğšğš’ğš˜ğš— that given two "optional" integers, adds them if they are both present (returning ğš‚ğ™¾ğ™¼ğ™´ of their sum), or returns ğ™½ğ™¾ğ™½ğ™´ if at least one of the two arguments is ğ™½ğ™¾ğ™½ğ™´.
Write a function ğšŠğšğšğ™°ğš•ğš•ğ™¾ğš™ğš : ğš’ğš—ğš ğš˜ğš™ğšğš’ğš˜ğš— ğš•ğš’ğšœğš -> ğš’ğš—ğš ğš˜ğš™ğšğš’ğš˜ğš— that given a list of "optional" integers, adds those integers that are there (i.e. adds all the ğš‚ğ™¾ğ™¼ğ™´ ğš’). For example: ğšŠğšğšğ™¾ğš™ğš ([ğš‚ğ™¾ğ™¼ğ™´ ğŸ·, ğ™½ğ™¾ğ™½ğ™´, ğš‚ğ™¾ğ™¼ğ™´ ğŸ¹]) = ğš‚ğ™¾ğ™¼ğ™´ ğŸº. If the list does not contain any ğš‚ğ™¾ğ™¼ğ™´ ğš’s in it, i.e. they are all ğ™½ğ™¾ğ™½ğ™´ or the list is empty, the function should return ğ™½ğ™¾ğ™½ğ™´.
Write a function ğšŠğš—ğš¢ : ğš‹ğš˜ğš˜ğš• ğš•ğš’ğšœğš -> ğš‹ğš˜ğš˜ğš• that given a list of booleans returns ğšğš›ğšğš if there is at least one of them that is ğšğš›ğšğš, otherwise returns ğšğšŠğš•ğšœğš. (If the list is empty it should return ğšğšŠğš•ğšœğš because there is no ğšğš›ğšğš.)
Write a function ğšŠğš•ğš• : ğš‹ğš˜ğš˜ğš• ğš•ğš’ğšœğš -> ğš‹ğš˜ğš˜ğš• that given a list of booleans returns ğšğš›ğšğš if all of them ğšğš›ğšğš, otherwise returns ğšğšŠğš•ğšœğš. (If the list is empty it should return ğšğš›ğšğš because there is no ğšğšŠğš•ğšœğš.)
Write a function ğš£ğš’ğš™ : ğš’ğš—ğš ğš•ğš’ğšœğš * ğš’ğš—ğš ğš•ğš’ğšœğš -> ğš’ğš—ğš * ğš’ğš—ğš list that given two lists of integers creates consecutive pairs, and stops when one of the lists is empty. For example: ğš£ğš’ğš™ ([ğŸ·,ğŸ¸,ğŸ¹], [ğŸº, ğŸ¼]) = [(ğŸ·,ğŸº), (ğŸ¸,ğŸ¼)].
Challenge: Write a version ğš£ğš’ğš™ğšğšğšŒğš¢ğšŒğš•ğš of ğš£ğš’ğš™, where when one list is empty it starts recycling from its start until the other list completes. For example: ğš£ğš’ğš™ğšğšğšŒğš¢ğšŒğš•ğš ([ğŸ·,ğŸ¸,ğŸ¹], [ğŸ·, ğŸ¸, ğŸ¹, ğŸº, ğŸ», ğŸ¼, ğŸ½]) = [(ğŸ·,ğŸ·), (ğŸ¸,ğŸ¸), (ğŸ¹, ğŸ¹), (ğŸ·,ğŸº), (ğŸ¸,ğŸ»), (ğŸ¹,ğŸ¼), (ğŸ·,ğŸ½)].
Lesser challenge: Write a version ğš£ğš’ğš™ğ™¾ğš™ğš of ğš£ğš’ğš™ with return type (ğš’ğš—ğš * ğš’ğš—ğš) ğš•ğš’ğšœğš ğš˜ğš™ğšğš’ğš˜ğš—. This version should return ğš‚ğ™¾ğ™¼ğ™´ of a list when the original lists have the same length, and ğ™½ğ™¾ğ™½ğ™´ if they do not.
Write a function ğš•ğš˜ğš˜ğš”ğšğš™ : (ğšœğšğš›ğš’ğš—ğš * ğš’ğš—ğš) ğš•ğš’ğšœğš * ğšœğšğš›ğš’ğš—ğš -> ğš’ğš—ğš ğš˜ğš™ğšğš’ğš˜ğš— that takes a list of pairs (ğšœ, ğš’) and also a string ğšœğŸ¸ to look up. It then goes through the list of pairs looking for the string ğšœğŸ¸ in the first component. If it finds a match with corresponding number ğš’, then it returns ğš‚ğ™¾ğ™¼ğ™´ ğš’. If it does not, it returns ğ™½ğ™¾ğ™½ğ™´.
Write a function ğšœğš™ğš•ğš’ğšğšğš™ : ğš’ğš—ğš ğš•ğš’ğšœğš -> ğš’ğš—ğš ğš•ğš’ğšœğš * ğš’ğš—ğš ğš•ğš’ğšœğš that given a list of integers creates two lists of integers, one containing the non-negative entries, the other containing the negative entries. Relative order must be preserved: All non-negative entries must appear in the same order in which they were on the original list, and similarly for the negative entries.
Write a version ğšœğš™ğš•ğš’ğšğ™°ğš : ğš’ğš—ğš ğš•ğš’ğšœğš * ğš’ğš—ğš -> ğš’ğš—ğš ğš•ğš’ğšœğš * ğš’ğš—ğš ğš•ğš’ğšœğš of the previous function that takes an extra "threshold" parameter, and uses that instead of 0 as the separating point for the two resulting lists.
Write a function ğš’ğšœğš‚ğš˜ğš›ğšğšğš : ğš’ğš—ğš ğš•ğš’ğšœğš -> ğš‹ğš˜ğš˜ğš•ğšğšŠğš— that given a list of integers determines whether the list is sorted in increasing order.
Write a function ğš’ğšœğ™°ğš—ğš¢ğš‚ğš˜ğš›ğšğšğš : ğš’ğš—ğš ğš•ğš’ğšœğš -> ğš‹ğš˜ğš˜ğš•ğšğšŠğš—, that given a list of integers determines whether the list is sorted in either increasing or decreasing order.
Write a function ğšœğš˜ğš›ğšğšğšğ™¼ğšğš›ğšğš : ğš’ğš—ğš ğš•ğš’ğšœğš * ğš’ğš—ğš ğš•ğš’ğšœğš -> ğš’ğš—ğš ğš•ğš’ğšœğš that takes two lists of integers that are each sorted from smallest to largest, and merges them into one sorted list. For example: ğšœğš˜ğš›ğšğšğšğ™¼ğšğš›ğšğš ([ğŸ·,ğŸº,ğŸ½], [ğŸ»,ğŸ¾,ğŸ¿]) = [ğŸ·,ğŸº,ğŸ»,ğŸ½,ğŸ¾,ğŸ¿].
Write a sorting function ğššğšœğš˜ğš›ğš : ğš’ğš—ğš ğš•ğš’ğšœğš -> ğš’ğš—ğš ğš•ğš’ğšœğš that works as follows: Takes the first element out, and uses it as the "threshold" for ğšœğš™ğš•ğš’ğšğ™°ğš. It then recursively sorts the two lists produced by ğšœğš™ğš•ğš’ğšğ™°ğš. Finally it brings the two lists together. (Don't forget that element you took out, it needs to get back in at some point). You could use ğšœğš˜ğš›ğšğšğšğ™¼ğšğš›ğšğš for the "bring together" part, but you do not need to as all the numbers in one list are less than all the numbers in the other.)
Write a function ğšğš’ğšŸğš’ğšğš : ğš’ğš—ğš ğš•ğš’ğšœğš -> ğš’ğš—ğš ğš•ğš’ğšœğš * ğš’ğš—ğš ğš•ğš’ğšœğš that takes a list of integers and produces two lists by alternating elements between the two lists. For example: ğšğš’ğšŸğš’ğšğš ([ğŸ·,ğŸ¸,ğŸ¹,ğŸº,ğŸ»,ğŸ¼,ğŸ½]) = ([ğŸ·,ğŸ¹,ğŸ»,ğŸ½], [ğŸ¸,ğŸº,ğŸ¼]).
Write another sorting function ğš—ğš˜ğš_ğšœğš˜_ğššğšğš’ğšŒğš”_ğšœğš˜ğš›ğš : ğš’ğš—ğš ğš•ğš’ğšœğš -> ğš’ğš—ğš ğš•ğš’ğšœğš that works as follows: Given the initial list of integers, splits it in two lists using divide, then recursively sorts those two lists, then merges them together with ğšœğš˜ğš›ğšğšğšğ™¼ğšğš›ğšğš.
Write a function ğšğšğš•ğš•ğ™³ğš’ğšŸğš’ğšğš : ğš’ğš—ğš * ğš’ğš—ğš -> ğš’ğš—ğš * ğš’ğš—ğš that given two numbers ğš” and ğš— it attempts to evenly divide ğš” into ğš— as many times as possible, and returns a pair (ğš, ğš—ğŸ¸) where ğš is the number of times while ğš—ğŸ¸ is the resulting ğš— after all those divisions. Examples: ğšğšğš•ğš•ğ™³ğš’ğšŸğš’ğšğš (ğŸ¸, ğŸºğŸ¶) = (ğŸ¹, ğŸ») because ğŸ¸*ğŸ¸*ğŸ¸*ğŸ» = ğŸºğŸ¶ and ğšğšğš•ğš•ğ™³ğš’ğšŸğš’ğšğš((ğŸ¹,ğŸ·ğŸ¶)) = (ğŸ¶, ğŸ·ğŸ¶)  because ğŸ¹ does not divide ğŸ·ğŸ¶.
Using ğšğšğš•ğš•ğ™³ğš’ğšŸğš’ğšğš, write a function ğšğšŠğšŒğšğš˜ğš›ğš’ğš£ğš : ğš’ğš—ğš -> (ğš’ğš—ğš * ğš’ğš—ğš) ğš•ğš’ğšœğš that given a number ğš— returns a list of pairs (ğš, ğš”) where ğš is a prime number dividing ğš— and ğš” is the number of times it fits. The pairs should be in increasing order of prime factor, and the process should stop when the divisor considered surpasses the square root of ğš—. If you make sure to use the reduced number ğš—ğŸ¸ given by ğšğšğš•ğš•ğ™³ğš’ğšŸğš’ğšğš for each next step, you should not need to test if the divisors are prime: If a number divides into ğš—, it must be prime (if it had prime factors, they would have been earlier prime factors of ğš— and thus reduced earlier). Examples: ğšğšŠğšŒğšğš˜ğš›ğš’ğš£ğš(ğŸ¸ğŸ¶) = [(ğŸ¸,ğŸ¸), (ğŸ»,ğŸ·)]; ğšğšŠğšŒğšğš˜ğš›ğš’ğš£ğš(ğŸ¹ğŸ¼) = [(ğŸ¸,ğŸ¸), (ğŸ¹,ğŸ¸)]; ğšğšŠğšŒğšğš˜ğš›ğš’ğš£ğš(ğŸ·) = [].
Write a function ğš–ğšğš•ğšğš’ğš™ğš•ğš¢ : (ğš’ğš—ğš * ğš’ğš—ğš) ğš•ğš’ğšœğš -> ğš’ğš—ğš that given a factorization of a number ğš— as described in the previous problem computes back the number ğš—. So this should do the opposite of ğšğšŠğšŒğšğš˜ğš›ğš’ğš£ğš.
Challenge (hard): Write a function ğšŠğš•ğš•_ğš™ğš›ğš˜ğšğšğšŒğšğšœ : (ğš’ğš—ğš * ğš’ğš—ğš) ğš•ğš’ğšœğš -> ğš’ğš—ğš ğš•ğš’ğšœğš that given a factorization list result from ğšğšŠğšŒğšğš˜ğš›ğš’ğš£ğš creates a list all of possible products produced from using some or all of those prime factors no more than the number of times they are available. This should end up being a list of all the divisors of the number ğš— that gave rise to the list. Example: ğšŠğš•ğš•_ğš™ğš›ğš˜ğšğšğšŒğšğšœ([(ğŸ¸,ğŸ¸), (ğŸ»,ğŸ·)]) = [ğŸ·,ğŸ¸,ğŸº,ğŸ»,ğŸ·ğŸ¶,ğŸ¸ğŸ¶]. For extra challenge, your recursive process should return the numbers in this order, as opposed to sorting them afterwards.
